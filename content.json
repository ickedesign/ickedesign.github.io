[{"title":"ES6语法学习笔记","date":"2017-06-28T02:47:03.000Z","path":"2017/06/28/20170628-ES6-SyntaxLearning/","text":"总结包含以下内容：let,const命令，解构赋值，正则扩展，字符串扩展，数值扩展，数组扩展，函数扩展，对象扩展，Symbol的用法，Set,Map数据结构，Map,Set与数组和对象的比较，Ploxy和Reflect，类和对象，Promise，Iterator和for..of循环，Generator，Decorator，模块化(更新完毕) ES6-SyntaxLearning 学习笔记 笔记发布在了segmentFault中，需要登录segmentFault才可查看 &nbsp;&nbsp;ES6语法学习—let,const命令 &nbsp;&nbsp;ES6语法学习—解构赋值 &nbsp;&nbsp;ES6语法学习—正则扩展 &nbsp;&nbsp;ES6语法学习—字符串扩展（上） &nbsp;&nbsp;ES6语法学习—字符串扩展（下） &nbsp;&nbsp;ES6语法学习—数值扩展 &nbsp;&nbsp;ES6语法学习—数组扩展 &nbsp;&nbsp;ES6语法学习—函数扩展 &nbsp;&nbsp;ES6语法学习—对象扩展 &nbsp;&nbsp;ES6语法学习—Symbol的用法 &nbsp;&nbsp;ES6语法学习—Set,Map数据结构 &nbsp;&nbsp;ES6语法学习—Map,Set与数组和对象的比较 &nbsp;&nbsp;ES6语法学习—Ploxy和Reflect &nbsp;&nbsp;ES6语法学习—类和对象 &nbsp;&nbsp;ES6语法学习—Promise &nbsp;&nbsp;ES6语法学习—Iterator和for…of循环 &nbsp;&nbsp;ES6语法学习—Generator &nbsp;&nbsp;ES6语法学习—Decorators &nbsp;&nbsp;ES6语法学习—模块化 笔记也同步在我的Github","tags":[{"name":"JS","slug":"JS","permalink":"http://icke.site/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"http://icke.site/tags/ES6/"}]},{"title":"《JavaScript设计模式与开发实践》读书笔记","date":"2017-06-14T13:57:00.000Z","path":"2017/06/14/20170614-JavaScript-JS_Pattern/","text":"总结包含以下内容：第二章 this、call和apply，等等（待更新） JS_Pattern 学习笔记 笔记发布在了segmentFault中 &nbsp;&nbsp;《JavaScript设计模式与开发实践》读书笔记—第二章 this、call和apply &nbsp;&nbsp;《JavaScript设计模式与开发实践》读书笔记—第三章 闭包","tags":[{"name":"JS","slug":"JS","permalink":"http://icke.site/tags/JS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://icke.site/tags/设计模式/"}]},{"title":"Web安全-XSS的攻击和防范","date":"2017-06-11T12:00:03.000Z","path":"2017/06/11/20170611-XSS-WebSecurity/","text":"总结包含以下内容：了解XSS的攻击方式和防范措施，并进行实战 XSS-WebSecurity 什么是XSS 简介 跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者通常往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的, 还有另外一种产常见的就是CSRF(Cross-site request forgery)跨站点请求伪造。 主要分类 反射型：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析响应之后，XSS代码随着响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。 存储型：存储型XSS和反射型XSS的差别在于,提交的代码会存储在服务器中(例如数据库,内存,文件系统等),下次请求页面时不用再提交XSS代码。 特点 1.耗时间 2.有一定几率不成功 3.没有响应的软件自动攻击 4.需要有一定的语言基础 5.这是一种被动的攻击手法 6.几乎所有的网站都存在Xss 谷歌，百度，QQ都有 其它的攻击 DoS(Denial of Service)拒绝服务攻击、DDoS(Distributed Denial of Service)分布式拒绝服务攻击 这两种攻击方式利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。单一的DoS攻击一般是采用一对一方式的，而DDoS利用更多的傀儡机（肉鸡）来发起进攻，以比从前更大的规模来进攻受害者。 Server Limit DOS服务器限制拒绝服务攻击 比如： 攻击导致http request header过长而导致web server产生404或者4开头的一个错误。如果浏览器中这些数据保存在cookies中，会导致用户无法正常访问域名或者这个站点 XSS的反射型攻击演示构建Node服务进行演示 1.新建文件夹，命令行输入： express -e ./使用express脚手架，用ejs作为模板引擎，在当前目录执行 npm install安装依赖 2.在routes/index.js下设置路由： 1234router.get('/', function(req, res, next) &#123; res.set('X-XSS-Protection',0); //关掉浏览器对XSS的检测 res.render('index',&#123; title:'Express',xss:req.query.xss &#125;); &#125;); //query是express获取search的字段 3.在views/index.ejs中的body部分添加： 123&lt;div class=&quot;&quot;&gt; &lt;%- xss %&gt;&lt;!--&apos;-&apos;表示允许输入html，不需要转义--&gt;&lt;/div&gt; 4.命令行输入： npm start开启服务器 5.在http://localhost:3000/后输入?xss=&lt;iframe src=&quot;//baidu.com/h.html&quot;&gt;&lt;/iframe&gt;或者?xss=&lt;img src=&quot;null&quot; onerror=&quot;alert(&quot;1&quot;)&quot;&gt;或者&gt;xss=&lt;p onclick=&quot;alert(&quot;1&quot;)&quot;&gt;点我&lt;/p&gt;进行模仿XSS的放射型攻击。第一个效果如下图： XSS的防范措施XSS不止是URL注入 ，或者评论代码注入，还有cookie 劫持等多种形式 对于评论代码注入的三大步骤： 编码：对用户输入的数据进行HTML Entity编码，比如字符&quot;转义成转义字符&amp;quot 过滤：移除用户上传的DOM属性，如onerror等，还有用户上传的Style节点、Script节点，Iframe节点，frame节点等 校正：避免直接对HTML Entity解码；使用DOM Parse转换，校正不配对的DOM标签（DOM Parse指将字符串或文本解析成DOM结构） 实战通过构建Node服务和建立一个评论功能，使用ajax实例演示XSS的攻击和预防 文本由服务器端转义，客户端反转义，再DomParse，再过滤 使用encode.js和domparse.js第三方库对文本进行解码和DOM parse操作 详见本人Github的两个文件routes/index.js和views/index.ejs，内含注释 效果图如下： XSS-WebSecurity-test2","tags":[{"name":"XSS","slug":"XSS","permalink":"http://icke.site/tags/XSS/"},{"name":"Web安全","slug":"Web安全","permalink":"http://icke.site/tags/Web安全/"}]},{"title":"移动端ICON制作、性能陷阱和硬件加速","date":"2017-05-24T17:20:20.000Z","path":"2017/05/25/20170525-HTML5-Performance/","text":"总结包含以下内容：基于HTML5,浅谈移动端ICON制作、性能陷阱和硬件加速 HTML5Performance ICON制作 使用Base64格式的图片制作ICON 可减少请求，加快首屏数据的显示速度，但体积大，未压缩，不易维护 CSS3制作ICON 在手机端的兼容性很好，体积小，但一般用在规则的图形 移动端性能陷阱 1、在PC时代会将&lt;script&gt;标签放在&lt;body&gt;的最底部，在移动端时代： 减少或避免repaint(页面重绘),reflow(页面回流)。会触发repaint的操作：比如样式上的变化，会触发reflow的操作：比如位置的改变 减少对DOM元素的操作（框架的做法是将DOM操作从DOM文档流中提取出来） 尽量缓存可以缓存的数据 2、在PC时代使用一般使用http来缓存(比如ResponseHeaders的Cache-Control等)，在移动端时代： localStorage（只能存储字符串，否则需要做序列化的处理） 123localStorage.setItem('data_1',JSON.stringify(&#123;a:1&#125;));localStorage.getItem('data_1');//\"&#123;\"a\":1&#125;\"JSON.parse(localStorage.getItem('data_1'))//Object &#123;a: 1&#125; sessionStorage（会话级别的存储） indexedDB(存大量数据，可建立索引) 3、使用CSS3 transform代替DOM操作，CSS3 transform由浏览器引擎底层提供渲染 非主流的硬件加速方法： 不要给非static定位元素增加CSS3动画（比如：absolute、relative） 适当地使用硬件加速（比如GPU），比如用Canvas绘画可触发GPU，加transform: translate3d(0,0,0)","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://icke.site/tags/HTML5/"},{"name":"WEB APP","slug":"WEB-APP","permalink":"http://icke.site/tags/WEB-APP/"}]},{"title":"HTML5 WEB APP的使用","date":"2017-05-17T02:34:30.000Z","path":"2017/05/17/20170517-HTML5-HTML5Analysis/","text":"总结包含以下内容：HTML5的应用场景，HTML5对比Native的优势，WEB+APP发展现状，HTML5 WEB APP的发展趋势 HTML5Analysis HTML5的应用场景 PC端：LocalStorage本地存储(渐强式体验：对支持HTML5的浏览器使用LocalStorage) 手机端： 基于Web View的Web Hybrid Native开发，优点是更新比较灵活 Web App开发：H5广告，H5游戏，H5网站 HTML5对比Native的优势 HTML5提供了符合语义化的标签，比如：&lt;article&gt;、&lt;section&gt;、&lt;header&gt;、&lt;output&gt;、&lt;figure&gt;、&lt;footer&gt; 对API更好的支持：SessionStorage、WebGL、Web Workers、Canvas Native虽然使用流畅，但更新慢，在App Store中还需审核。可以试想一下一次开发多终端受益（嵌在Web View中） WEB+APP发展现状 现状：不能一次开发多终端适配 在PC时代，多终端适配指浏览器适配 在移动端时代，其指手机系统的适配（Antroid、Apple的按键使用不同，比如返回键） Native App与Hybrid App的体验差：动画方面和DPM操作 手机的CPU（计算）和GPU（图形渲染）比PC慢 Native App在手机端的效果比较好的原因： 在WEB APP和Hybrid App上的编译过程是：JS编译成JAVA再编译成机器语言，最后运行 Native App没有编译过程，性能快很多 因此目前网页的性能是不能匹敌Native App的 提出一次开发多终端适配的原因： Media Query的出现，针对设备分辨率进行适配，出现响应式页面。但这需要在性能和效果之间做出权衡 CSS3：在HTML5时代使用CSS3的animation属性来代替DOM的动画操作。例如用transform接口来实现手机Web页面的Tab切换 HTML5 WEB APP的发展趋势 WEB APP正在尝试无限接近Native App FaceBook之前不断使用HTML5技术去更新APP，后来出现了APP卡顿的现象，继而使用Native技术去替换更新。这是一次尝试 与HTML5有关的框架是React 通过JS来编写逻辑，通过Native实现界面效果 Native用来构建User Interface，即用户界面，解决了Web App的一个痛点，即构建页面的性能平均问题","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://icke.site/tags/HTML5/"},{"name":"WEB APP","slug":"WEB-APP","permalink":"http://icke.site/tags/WEB-APP/"}]},{"title":"CSS易混淆点小总结","date":"2017-03-12T14:53:30.000Z","path":"2017/03/12/20170312-CSS-Study-CSS-Layout/","text":"总结包含以下内容：CSS hack、清除浮动(clearfix hack)、CSS伪类和伪元素、Box-Sizing、水平居中和垂直居中、em和rem的区别、max-width、@media媒体查询、columns、@import加载CSS文件和link的区别、使用CDN、Flex布局 Study CSS Layout CSS hack因为不同浏览器对CSS的兼容不同，所以需要hack来对CSS做一些兼容。常用的有四种方法： 条件注释法 在使用Bootstrap时，经常可以在&lt;head&gt;&lt;/head&gt;中看到有以下这段： 1234&lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 这就是条件注释法，把其中的内容换成link链接即可。条件注释法还有兼容其它IE浏览器的写法： 12345678910&lt;!--[if !IE]&gt; 除IE外都可识别&lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt; 正确的CSS hack的一种写法是： 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css1.css\" /&gt;&lt;!--[if lt IE 9]&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css2.css\" /&gt;&lt;![endif]--&gt; 解释一下最上方的Bootstrap代码： html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。让CSS 样式应用在未知元素上只需执行 document.createElement(elementName) 即可实现。html5shiv就是根据这个原理创建的 引入respond.js，让低浏览器支持css3的新属性，比如@media媒体查询的使用。使用respond.js注意以下几点： Respond.js 与 跨域（cross-domain） CSS 的问题，解决方法：样式文件跨域导致Respond.js插件在IE浏览器失效的问题 Respond.js 与 file:// 协议，由于浏览器的安全机制，Respond.js 不能在通过 file:// 协议（打开本地HTML文件所用的协议）访问的页面上发挥正常的功能。如果需要测试 IE8 下面的响应式特性，务必通过 http 协议访问页面（例如搭建 apache、nginx 等）。 Respond.js 与 @import 指令，Respond.js不支持通过 @import指令所引入的 CSS 文件。 类内属性前缀法在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果比如： 1background-color:blue !important;/* All browsers but IE6 */ 选择器前缀法比如\\*html， \\*前缀只对IE6生效 CSS3选择器结合JavaScript的Hack 以上更详细的解释，请点击史上最全的CSS hack方式一览 参考资料 条件注释判断浏览器版本 Html5shiv Bootsrap对浏览器和设备的支持情况 史上最全的CSS hack方式一览 清除浮动(clearfix hack)以下是Bootsrap下的写法123456789101112.clearfix &#123; zoom: 1; &#125; .clearfix:before, .clearfix:after &#123; display: table; line-height: 0; content: \"\"; &#125; .clearfix:after &#123; clear: both; &#125; 奇舞团的老师在慕课网上讲课时，使用的是以下的方法12345678910.clearfix:after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123;display: inline-block;&#125;* html .clearfix &#123;height: 1%;&#125;.clearfix &#123;display: block;&#125; 更详细的clearfix hack，请点击What methods of ‘clearfix’ can I use?。但肯定的是，为了不破坏HTML的文档结构，clearfix hack要使用CSS的伪元素:before和:after 参考资料 What methods of ‘clearfix’ can I use? CSS伪类和伪元素1.:after/::after和:before/::before都是CSS伪元素，与:hover/:active等伪类不一样。2.:before/:after伪元素是在CSS2中提出来的，所以兼容性到IE8了。3.::before/::after是CSS3中的写法，为了将伪类和伪元素区分开。但是平时为了兼容性，还是会用一个冒号的写法 想了解更多，请点击CSS 伪元素和CSS 伪类 关于伪类:before和:after中content的内容 [String]，使用引号包括一段字符串，将会向元素内容中添加字符串。示例： 1a:after &#123; content: \"↗\"; &#125; attr()，调用当前元素的属性，可以方便的比如将图片的 Alt 提示文字或者链接的 Href 地址显示出来。示例： 123a:after &#123; content:\"(\" attr(href) \")\"; &#125; url()或uri()，用于引用媒体文件。示例： 123h1:before &#123; content: url(logo.png); &#125; counter()，调用计数器，可以不使用列表元素实现序号功能。具体请参见 counter-increment 和 counter-reset 属性的用法。示例： 1234h2:before &#123; counter-increment: chapter; content: \"Chapter \" counter(chapter) \". \" &#125; 伪类元素:nth-child() 和:nth-of-type() :nth-child():做手机网站的时候，由于手机网站对浏览器兼容要求相对较低，手机浏览器大部分都支持css3，这就大大提高了开发效率。可以随意使用CSS3:nth-child()伪类选择器。IE9及以上版本，火狐，谷歌，Safari ，Opera都支持:nth-child() :nth-child(n)与:nth-of-type(n)的区别 ele:nth-child(n) 选择器匹配属于其父元素的第n个子元素，不论元素的类型。n 可以是数字、关键词或公式。比如ele:nth-child(odd),即匹配序号为奇数的元素 ele:nth-of-type(n) 选择器的意思是“规定属于其父元素的第n个ele元素” 参考资料 :after/::after和:before/::before的区别 谈谈css的伪类和伪元素 CSS3的nth-child()选择器 Box-Sizing box-sizing属性可以为三个值之一：content-box（default），border-box，padding-boxcontent-box，border和padding不计算入width之内padding-box，padding计算入width内border-box，border和padding计算入width之内，其实就是怪异模式了 ie8+浏览器支持content-box和border-box，ff则支持全部三个值 个人推荐使用border-box，因为padding-box只能在ff中得到支持 参考资料 css3 box-sizing属性 水平居中和垂直居中水平居中和垂直居中要分三种情况来分析，一是display类型，二是单行还是多行居中，三是是否事先知道对象的宽高。更加详细请戳参考资料 参考资料 关于居中一 关于居中二 em和rem的区别 em的参考对象是父级元素 任意浏览器的默认字体高都是16px，为了简化font-size的换算，需要在css中的body选择器中声明 Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了 rem是CSS3新增的一个相对对象，参考对象是HTML对象的根元素 除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小 使用 rem 单位的主要目的应该是确保无论用户如何设置自己的浏览器，我们的布局都能调整到合适大小。 注意不要在多列布局中使用em或rem,改用%。什么时候使用em和rem可以戳一下参考资料链接 参考资料 何时使用 Em 与 Rem max-width使用max-width替代width可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要，调整下浏览器窗口大小可以检查一下。顺便提下， 所有的主流浏览器包括IE7+在内都支持max-width所以放心大胆的用吧 @media媒体查询基本格式如以下说示123@media (min-width: 768px)&#123; //&gt;=768的设备 &#125;@media (min-width: 992px)&#123; //&gt;=992的设备 &#125;@media (min-width: 1200)&#123; //&gt;=1200的设备 &#125; 123@media (max-width: 1199)&#123; //&lt;=1199的设备 &#125;@media (max-width: 991px)&#123; //&lt;=991的设备 &#125;@media (max-width: 767px)&#123; //&lt;=768的设备 &#125; 注意大小的顺序，另外也可以这么使用，如以下 123@media screen and (min-width: 960px) and (max-width: 1199px) &#123; #page&#123; width: 960px; &#125;#content,.div1&#123;width: 650px;&#125;#secondary&#123;width:250px&#125;select&#123;max-width:200px&#125;&#125; 使用@media就能做出自适应的布局了 参考资料 利用@media screen实现网页布局的自适应 columns columns是CSS3的新属性，Internet Explorer 9 以及更早版本的浏览器不支持 column 属性。 属性有Column-count(列的数目)、Column-gap(列的间隔)、Column-width(列的宽度)和Column-rule 前缀 -webkit-,-moz- 参考资料 CSS3 columns 属性 @import加载CSS文件和link的区别个人觉得比较重要的五个不同如以下所示： 引用的方式不同link(外部引用): 1&lt;link rel=\"stylesheet\" href=\"xxx.css\" type=\"text/css\" / &gt; @import(导入式):@import url(xxx.css); 放置的位置不同link一般放在head标签中 @import必须放在&lt;style type=&quot;text/css&quot;&gt;标签中 加载内容不同link可以加载除了css文件外，还可以加载MIME类型的文件 当使用 Javascript 控制 DOM 去改变样式的时候，只能使用 link 方式，因为@import眼里只有CSS，不是 DOM 可以控制的； 加载方式不同link会和dom结构一同加载渲染@import只能等dom结构加载完成以后才能渲染页面 参考资料 外部引用css时，link和@import两种区别 使用CDN 什么是CDNCDN的全称是Content Delivery Network，即内容分发网络。是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络 “ 边缘 “ ，使用户可以就近取得所需的内容，解决 Internet 网络拥塞状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，造成的用户访问网站的响应速度慢的问题 使用CDN有利有弊 参考资料 CDN使用心得 Flex布局Flex布局可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。兼容IE10+。了解更多请看下阮一峰老师的教程。 参考资料 Flex 布局教程：语法篇 Flex 布局教程：实例篇","tags":[{"name":"CSS","slug":"CSS","permalink":"http://icke.site/tags/CSS/"}]},{"title":"关于arr[i++]与arr[++i]","date":"2017-03-10T07:07:20.000Z","path":"2017/03/10/20170310-JavaScript-arr[i++]/","text":"总结包含以下内容：i++和++i&nbsp; 的区别，i++和++i&nbsp; 在循环中的区别，arr[i++]和arr[++i]&nbsp; 在循环中的区别，arr[i++]+=1和arr[++i]+=1&nbsp; 在循环中的区别，arr[i++]的使用 Array-arr++ 前几天做Canvas倒计时的时候，慕课网的老师讲到了一个及时清除不在画布中的小球的做法。以下是实现代码： 123456789101112//及时清空跳出画布的小球，优化页面的内存var cnt=0for(var i=0;i&lt;balls.length;i++)&#123; if(balls[i].x+radius&gt;0&amp;&amp;balls[i].x-radius&lt;canvasWidth)&#123; //小球数组中的第0个到cnt-1个是在canvas画布中 balls[cnt++]=balls[i]; &#125;&#125;//删除前面的数组使用balls.shift()while(balls.length&gt;cnt)&#123; balls.pop();//删除第cnt个到balls.length-1个数组&#125; arr[i++]是什么呢？于是开始一步一步地探索 i++和++i大一的时候上java课，老师讲过了这样的题，想必学过计算机相关的都知道&nbsp; &nbsp; (/▽╲) 1234567891011var a=1;var b=2;a=b++;console.log(\"a的值是：\"+a+\"，\"+\"b的值是：\"+b);//\"a的值是：2，b的值是：3\"var c=1;var d=2;c=++d;console.log(\"c的值是：\"+c+\"，\"+\"d的值是：\"+d);//\"c的值是：3，d的值是：3\" a=b++是b先把值赋给a，自身再加1；a=++b是b先自身加1，再把值赋给a i++和++i&nbsp; 在循环中的区别 i++在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(i++); //依次输出0,2,4&#125; ++i在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(++i); //依次输出1,3,5&#125; arr[i++]和arr[++i]在循环中的区别 arr[i++]在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i++]); //依次输出11,13,15&#125; arr[++i]在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[++i]); //依次输出12,14,16&#125; 如果数组是奇数个，那么输出arr[++i]的最后一个数会是一个undefined arr[i++]+=1和arr[++i]+=1在循环中的区别 arr[i++]+=1在循环中的输出： 1234567var arr=[1,2,3];for(var i=0;i&lt;arr.length;i++)&#123; arr[i++]+=1;&#125; console.log(arr);//输出[2,2,4] arr[++i]+=1在循环中的输出： 1234567var arr=[1,2,3];for(var i=0;i&lt;arr.length;i++)&#123; arr[++i]+=1;&#125; console.log(arr);//输出[1,3,3,NaN] 由于数组是奇数个，所以最后arr[++i]+=1最后的输出结果是NaN，可以通过以下的代码验证 12console.log(undefined+1);//输出NaN arr[i++]的使用12345678910111213141516171819202122232425262728var arr=[ &#123;x: 1&#125;, &#123;x: 5&#125;, &#123;x: 9&#125;, &#123;x: 3&#125;, &#123;x: 10&#125;, &#123;x: 6&#125;]var cnt=0;for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i].x&lt;4)&#123; arr[cnt++]=arr[i]; console.log('cnt的值是'+cnt+'，i的值是'+i); //\"cnt的值是1，i的值是0\" //\"cnt的值是2，i的值是3\" &#125; &#125; while(arr.length&gt;cnt)&#123; arr.pop();&#125;console.log(arr);// [// [object Object] &#123;x: 1&#125;, // [object Object] &#123;x: 3&#125;// ] 这说明了第0到cnt-1个留在arr中，cnt到arr.length-1的数组删除，使用这个技巧就可以来去除不符合判断语句的数组了","tags":[{"name":"JS","slug":"JS","permalink":"http://icke.site/tags/JS/"},{"name":"数组","slug":"数组","permalink":"http://icke.site/tags/数组/"}]},{"title":"Canvas绚丽倒计时学习笔记","date":"2017-03-09T05:14:50.000Z","path":"2017/03/09/20170309-Canvas-Countdown/","text":"总结包含以下内容：创建画布，绘制直线，绘制弧线，绘制静止的时钟，设置倒计时效果，让倒计时动起来，小球的运动，及时清空Canvas画布外面的小球，将倒计时的效果换成正常时钟效果 Canvas-Clock 关于Canvas：HTML5 &lt;canvas&gt; 标签用于绘制图像（通过脚本，通常是 JavaScript）。不过，&lt;canvas&gt;元素本身并没有绘制能力（它仅仅是图形的容器），必须使用脚本来完成实际的绘图任务。&nbsp;&nbsp;[该叙述来自W3CSCHOOL]演示： Gorgeous Countdown GorgeousCountdown-Sketch Creat Canvas 创建画布 canvas是行内元素，有默认的高宽（300px*150px） display: block可以把&lt;canvas&gt;&lt;/canvas&gt;变成块级元素,从而可以通过margin: 0 auto;设置为水平居中 canvas有显示的大小，还有内里分辨率的大小，所以不能在css中设置canvas的宽高。可以使用以下两种方法设置 12&lt;!--直接在标签头设置--&gt;&lt;canvas width=\"1024\" height=\"500\"&gt;&lt;/canvas&gt; 1234//在js中设置var canvas=document.getElementById('canvas');canvas.width=\"1024\";canvas.height=\"500\"; &lt;canvas&gt;是HTML5的新标签，所以存在兼容问题。注意：若把判断条件改成canvas.getContext(&quot;2d&quot;)会出错 123456if(canvas.getContext)&#123; var context=canvas.getContext('2d'); &#125;else&#123; alert('当前浏览器不支持canvas，请更换浏览器后再试');&#125; Draw Line 绘制直线 备注：以下的context，默认由var context=canvas.getContext(&quot;2d&quot;)取得 context.closePath()的存在会让未闭合的线条自动闭合，所以用不用看情况。总之，一个Canvas画布如果没有使用context.beginPath()，那么画布上的其它图形会受到影响 context.moveTo(x1,y1)用来定义画笔的起始位置context.lineTo(x2,y2)用来定义画笔的终止位置 1234567//画一个闭合图形context.beginPath();context.moveTo(x1,y1);context.lineTo(x2,y2);context.lineTo(x1,y2);context.moveTo(x1,y1);context.closePath(); context.lineWidth=num定义画笔大小context.strokeStyle=&quot;color&quot;定义画笔颜色context.stroke() 执行绘图的方法context.fillStyle=&quot;color&quot;定义填充的颜色context.fill() 执行着色的方法 使用以上方法，即可绘制一个七巧板： Canvas Tangram Draw Arc 绘制弧线 context.arc(300,300,0,1.5*Math.PI,false) 的含义是沿顺时针的方向来绘制一个圆心为（300，300），角度为1.5π 12context.arc(centerx,centery,radius,startingAngle,endingAngle,anticlockwise=false);//默认clockwise=false，即在逆时针的方向上以角度为 0,0.5*PI,1*PI,1.5*PI,2*PI这种形式绘图 Draw Digit 绘制静止的时钟 先编写一个三维数组，来显示数字和冒号。这里以0和：来举例 12345678910111213141516171819202122232425262728//数字有7列10行组成，冒号由4列10行组成，数组中有1的地方就是代表有小球digit = [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0] ]//: ]; 通过循环数组，定义好小球之间的距离，即可画出小球。不过说得容易，逻辑对我们这些初学者有点复杂。感兴趣可以看下我github上的文件：drawDigit.js Countdown Effect 设置倒计时效果 获取倒计时的时间使用设置好的时间减去现在的时间，这个设置好的时间可以使用new Date()生成，比如const endTime=new Date(2017,2,7,20,14,12)。其中月份是从0开始的，所以这个时间的含义是2017-03-07，20：14：12 也可以使用以下的方法来设置固定的时间，比如倒计时时间固定从1小时开始 12var endTime=new Date();endTime.setTime(endTime.getTime()+3600*1000); 注意分清var、const和let三个定义变量的区别： var定义的变量可以修改，如果不初始化会输出undefined，不会报错 const定义的变量不可以修改，而且必须初始化 let是块级作用域，函数内部使用let定义后，对函数外部无影响 Moving Clock 让倒计时动起来 使用setInterval()方法更新，从而数字可以变化而更新生成新的小球的位置12345678910111213141516//添加时钟的动画效果setInterval( function()&#123; render(context);//初始化时间 update();//对时间进行更新 &#125;, 50 //一秒有1000毫秒，即20分之1， //所以帧率为20，即动画1秒钟更新20次。但事实上，因为里面的函数执行效率不同，所以帧数不一定为20)``` * `context.clearRect(x,y,canvasWidth,canvasHeight);`其中x,y指的是清除矩形画布的左上角位置，canvasWidth,canvasHeight指的是清除矩形画布的宽度和长度。使用该函数可以让canvas中后来生成的图形不会和原来的图形叠加在一起了，相反效果的是`context.fillRect()`，其作用是填充矩形，参数类似```jscontext.clearRect(0,0,context.canvas.width,context.canvas.height);//从右上角开始，范围是整个画布//使用context.canvas.width来获取canvas的宽度是context的属性之一 Ball Motion 小球的运动 小球的运动很有趣，和高中物理课上的抛物线一样，有初始速度，重力加速度，摩擦系数 小球的运动也需要借助setInterval()方法来更新，类似时钟的动画效果 小球触底后反弹使用if语句来判断12345//当小球触底后会反弹if(canvasHeight-ball.y&lt;=ball.r)&#123; ball.y=canvasHeight-ball.r; ball.vy=-ball.vy*0.5;//添加阻力系数&#125; Performance Optimization 及时清空Canvas画布外面的小球 核心是balls[cnt++]=balls[i]这个表达式，我一开始也是有点懵逼。后来做了下试验就明白了12345678910111213//及时清空跳出画布的小球，优化页面的内存var cnt=0for(var i=0;i&lt;balls.length;i++)&#123; if(balls[i].x+radius&gt;0&amp;&amp;balls[i].x-radius&lt;canvasWidth)&#123; //小球数组中的第0个到cnt-1个是在canvas画布中 balls[cnt++]=balls[i]; &#125;&#125;//Math.min();两个数取最小值while(balls.length&gt;Math.min(250,cnt))&#123; balls.pop();//删除第cnt个到balls.length-1个数组 //删除前面的数组使用balls.shift();&#125; Clock Effect 将倒计时的效果换成正常时钟效果 比较简单1var ret=currentTime.getHours()*3600+currentTime.getMinutes()*60+currentTime.getSeconds(); 参考资料 HTML 5 Canvas 参考手册) 炫丽的倒计时效果Canvas绘图与动画基础","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://icke.site/tags/HTML5/"},{"name":"Canvas","slug":"Canvas","permalink":"http://icke.site/tags/Canvas/"}]},{"title":"JavaScript正则表达式基础归纳","date":"2017-03-05T06:02:37.000Z","path":"2017/03/05/20170305-JavaScript-RegExp/","text":"归纳包含以下内容： 正则表达式简介、工具使用、RegExp对象、元字符、字符类、范围类、JS预定义类、量词、JS正则的贪婪模式和非贪婪模式、分组、前瞻、JS对象属性、test和exec方法、字符串对象方法 JS-RegExp 正则表达式简介Regular Expression，即正则表达式。使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 工具使用在线显示正则表达式的图形工具: &nbsp; regexper官网 以下为Sublime使用的三种演示： 首先，在sublime中，使用快捷键ctrl+h打开replace窗口，再点击“*”，这样就可以在Sublime的输入框中输入正则表达式来查找字段 在sublime中，使用快捷键ctrl+h打开replace窗口，再点击“*”，这样可以在输入框中输入正则表达式来查找 将is这个单词替换成IS 待处理字段：12//将is这个单词替换成ISthis is a boy 在输入框中输入： 这里写图片描述 正则表达式图形表示： 这里写图片描述 成功处理字段： 123//test.txt//将is这个单词替换成ISthis IS a boy 去掉含有jpg后缀的http地址中的http:// 待处理字段： 1234//去掉含有jpg后缀的http地址中的http://http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 在输入框中输入： 这里写图片描述 正则表达式图形表示： 这里写图片描述 备注：注意符号/要使用\\来转义，即\\/. 表示any character，任意字符+表示不限量()内是第一个分组 成功处理字段： 1234//去掉含有jpg后缀的http地址中的http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 日期替换，将日期格式如2013-01-13替换成01-13-2013 待处理字段：1234//日期替换，将日期格式如2013-01-13替换成01-13-20132014-11-122015/04/0623771/34/22 在输入框中输入： 这里写图片描述 正则表达式图形表示： 这里写图片描述 成功处理字段： 1234//日期替换，将日期格式如2013-01-13替换成01-13-201311-2014-1204-2015-0623771/34/22 RegExp对象有两种方法实例化RegExp对象，即字面量和构造函数。 字面量 12var reg=/\\bis\\b/g;'He is a boy.This is a dog'.replace(reg,'IS'); 构造函数 12var reg=new RegExp('\\\\bis\\\\b','g');'He is a boy.This is a dog'.replace(reg,'IS'); 备注： \\要转义 这里写图片描述 元字符正则表达式由两种基本字符类型组成： 原意文本字符 元字符 元字符是在正则表达式中有特殊含义的非字母字符：*+?$^.|(){}[] 字符 含义 \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 \\cX 与X对应的控制字符（Ctrl+X） 字符类 一般情况下正则表达式一个字符对应字符串一个字符例如：表达式ab\\t的含义是 这里写图片描述 我们可以使用元字符[]来构建一个简单的类所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符表达式[abc]，即把字符a或b或c归为一类，表达式可以匹配这类的字符字符类取反：[^abc] 这里写图片描述 范围类 [a-z]，闭区间 [a-zA-Z]，可连写 这里写图片描述 JS预定义类 预定类 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\v\\f\\r\\n] 空白符 \\S [^\\t\\v\\f\\r\\n] 非空白符 \\w [a-zA-Z_0-9] 单词字符（字母、数字下划线） \\W [^a-zA-Z_0-9] 非单词字符 备注：空白符为[ \\t\\n\\x0B\\f\\r]，空字符为\\0，\\0代表查找NULL字符验证： 这里写图片描述 边界 字符 含义 ^ 以xxx开始 $ 以xxx结束 \\b 单词边界 \\B 非单词边界 举例： \\b，\\B的使用 这里写图片描述 ^$的使用 这里写图片描述 多行匹配，/m影响的是^$的分割方式 这里写图片描述 量词 字符 含义 ? 0次或1次（最多一次） + 1次或1次以上（至少一次） * 0次或多次 (任意次) {n} 出现n次 {n,m} 出现n次到m次 {n,} 至少出现为n次 {0,m} 最多出现m次 举例： 1\\d?\\d+\\d*\\d&#123;6&#125;\\d&#123;3,6&#125;\\d&#123;3,&#125;\\d&#123;0,6&#125; 这里写图片描述 JS正则的贪婪模式和非贪婪模式 贪婪模式量词为{n,m}时，正则表达式尽可能多得往m匹配 非贪婪模式在量词{n,m}后面加上? 举例： 这里写图片描述 分组 分组使用()来实现分组：Byron{3}指的是n出现3次；(Byron){3}指的是Byron出现3次 1/Byron&#123;3&#125;(Byron)&#123;3&#125;/ 这里写图片描述 或使用|来实现或Byron|Casper和Byr(on|Ca)sper 1/Byron|Casper(Byr(on|Ca)sper)/ 这里写图片描述 反向引用使用$符：将2016-07-13转换为07/13/2016 1'2014/02/23'.replace(/(\\d&#123;4&#125;)\\/(\\d&#123;2&#125;)\\/(\\d&#123;2&#125;)/g,'$2-$3-$1'); 这里写图片描述 忽略分组不希望捕获某些分组。只需要在分组内加上?: 1/(?:Byron).(123)/ 这里写图片描述 前瞻 前瞻就是正则表达式匹配到规则的时候，向前检查是否符合断言。“前”指的是从文本头部到文本尾部的方向 后顾和前瞻方向相反，javascript中不支持 符合断言称为正向匹配或肯定匹配；不符合断言称为负向匹配或否定匹配 名称 正则 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 举例： 这里写图片描述 JS对象属性 global ：全局匹配，默认值为false ignoreCase ：忽略大小写，默认值为false multiline ：多行匹配，默认值为false lastIndex ：当前表达式匹配内容的最后一个字符的下一个位置 source ：正则表达式的文本字符串 备注：global、ignore case、multiline为只读 举例： 这里写图片描述 test和exec方法 test()RegExp.prototype.test(str) 用于测试字符串参数中是否存在匹配正则表达式模式的字符串。可以发现，在全局调用下，即对于reg2，在第三次test匹配时出现了false，这是因为在全局调用下lastIndex不为0。 这里写图片描述 每次都实例化reg2可以使test匹配时不出现false,但这花费内存开销。所以当我们想用到test本义时，不用加上/g来进行全局匹配 这里写图片描述 exec() RegExp.prototype.exec(str) 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果 如果没有匹配的文本则返回null，否则返回一个结果数组： index 声明匹配文本的第一个字符位置 input 存放被检索的字符串string 两种调用方式： 非全局调用 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话） 第三个元素是与RegExpObject的第二个子表达式相匹配的文本（如果有的话），以此类推 在非全局调用下，lastIndex不生效，会被正则忽略，默认为0 全局调用 非全局调用类似，不同的是lastIndex生效 字符串对象方法 search()String.prototype.search(reg) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果的index，查找不到返回-1； search()方法不执行全局匹配，它将忽略/g，并且总是从字符串的开始进行检索 备注：对于字符串或数字，search()方法会尝试转化为正则表达式 match()String.prototype.match(reg) match()方法将检索字符串，以找到一个或多个与regexp匹配的文本 regexp是否具有标志g对结果影响很大 两种调用方式 非全局调用 如果regexp没有标志g，那么match()方法就只能在字符串中执行一次匹配：(1) 如果没有找到任何匹配的文本，将返回null；(2) 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 除了常规的数组元素之外，返回的数组还含有2个对象属性：(1) index声明匹配文本的起始字符在字符串的位置；(2) input声明对stringObject的引用 备注：与exec()的非全局调用方法类似，只是match()方法是String.prototype.match(reg)，exec()方法是RegExp.prototype.match(str) 全局调用 如果regexp具有标志g，则match()方法将执行全局检索，找到字符串中的所有匹配子字符串：(1) 没有找到任何匹配的字串，则返回null；(2) 如果找到了一个或多个匹配字串，则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性 split()String.prototype.split(reg) 使用字符串或正则表达式来将原字符串分割成字符数组 这里写图片描述 备注： split()方法将字符串转换为对应正则表达式 replace()String.prototype.replace String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function) function会在每次匹配替换的时候调用，有四个参数 匹配字符串 (match) 正则表达式分组内容，没有分组则没有改参数 (group1,group2……) 匹配项在字符串中的index (index) 原字符串 (origin) 参考资料 JavaScript正则表达式","tags":[{"name":"JS","slug":"JS","permalink":"http://icke.site/tags/JS/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://icke.site/tags/正则表达式/"}]}]